<html>

<head>
    <script type="text/javascript" src="opencv.js"></script>
    <script>
        function Utils(errorOutputId) {
            this.loadImageToCanvas = function (url, cavansId) {
                return new Promise(resolve => {
                    let canvas = document.getElementById(cavansId);
                    let ctx = canvas.getContext('2d');
                    let img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = function () {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        resolve();
                    };
                    img.src = url;
                })
            };
        }
    </script>
    <style>
        .marker {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            padding: 0 8 0 8;
            color: white;
        }
    </style>
</head>

<body style="margin: 0;">
    <canvas id="imageCanvasInput" width="400" height="400" hidden></canvas>
    <div style="display: flex; overflow: hidden; height: 100%;">
        <div>
            <div
                style="position: absolute;width: 135px;height: 132px;text-align: center; z-index: -1; border: 5px dashed orange;">
                Click to upload
                decoded map or Ctrl+V to upload a snip</div>
            <canvas id="templateCanvasInput" width="90" height="100" onclick="templateInput.click()"
                style="width: 145px;"></canvas>

            <input id="templateInput" hidden type="file" onchange="onTemplateChange(event)" />
        </div>
        <div id="outputContainer" style="overflow: auto; position: relative;">
            <canvas id="canvasOutput"></canvas>
        </div>
    </div>
    <script>
        const utils = new Utils();
        utils.loadImageToCanvas('Felucca_crop.png', 'canvasOutput');

        async function onTemplateChange(e) {
            let files = e.target.files;
            if (files.length > 0) {
                let imgUrl = URL.createObjectURL(files[0]);
                await utils.loadImageToCanvas(imgUrl, 'templateCanvasInput');
                search();
            }
        }

        (async (params) => {
            const witcherLocationCsv = await fetch("Witchers_Tmap_Locations.csv").then(res => res.text())
            console.log({ witcherLocationCsv })
            witcherLocationCsv.split('\r\n').forEach(location => {
                const locationEls = location.split(',');
                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.textContent = locationEls[0];
                marker.style.left = locationEls[1];
                marker.style.top = locationEls[2];
                outputContainer.appendChild(marker);
            })
        })();

        let src;

        cv.then(async (cv) => {
            window.cv = cv;
            console.log(cv.getBuildInformation());
            await utils.loadImageToCanvas('Felucca_crop.bmp', 'imageCanvasInput');
            src = new cv.imread('imageCanvasInput');
        })

        document.onpaste = function (event) {
            var items = (event.clipboardData || event.originalEvent.clipboardData).items;
            console.log(JSON.stringify(items)); // might give you mime types
            for (var index in items) {
                var item = items[index];
                if (item.kind === 'file') {
                    var blob = item.getAsFile();
                    var reader = new FileReader();
                    reader.onload = async function (event) {
                        await utils.loadImageToCanvas(event.target.result, 'templateCanvasInput');
                        // console.log(event.target.result); // data url!
                        search();
                    };
                    reader.readAsDataURL(blob);
                }
            }
        };

        function search() {
            let templ = new cv.imread('templateCanvasInput');
            let dst = new cv.Mat();
            let mask = new cv.Mat();
            cv.matchTemplate(src, templ, dst, cv.TM_SQDIFF_NORMED, mask);
            console.log({ mask })
            let result = cv.minMaxLoc(dst, mask);
            let maxPoint = result.minLoc;
            console.log({ maxPoint })
            let color = new cv.Scalar(255, 0, 0, 255);
            let point = new cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);
            cv.rectangle(src, maxPoint, point, color, 2, cv.LINE_8, 0);
            cv.imshow('canvasOutput', src);
            // src.delete(); dst.delete(); mask.delete();

            const left = maxPoint.x - outputContainer.clientWidth / 2 + templateCanvasInput.width / 2;
            const top = maxPoint.y - outputContainer.clientHeight / 2 + templateCanvasInput.height / 2;
            outputContainer.scroll({ left, top, behavior: "smooth" })
        }
    </script>
</body>

</html>